import "./chunk-XML7UXAA.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  bind,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  prop_dev,
  run_all,
  safe_not_equal,
  space,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-SKZ77QWX.js";
import "./chunk-LYBY5SRM.js";
import "./chunk-2B2CG5KL.js";

// node_modules/@bulatdashiev/svelte-slider/src/slider.js
function handle(node) {
  const onDown = getOnDown(node);
  node.addEventListener("touchstart", onDown);
  node.addEventListener("mousedown", onDown);
  return {
    destroy() {
      node.removeEventListener("touchstart", onDown);
      node.removeEventListener("mousedown", onDown);
    }
  };
}
function getOnDown(node) {
  const onMove = getOnMove(node);
  return function(e) {
    e.preventDefault();
    node.dispatchEvent(new CustomEvent("dragstart"));
    const moveevent = "touches" in e ? "touchmove" : "mousemove";
    const upevent = "touches" in e ? "touchend" : "mouseup";
    document.addEventListener(moveevent, onMove);
    document.addEventListener(upevent, onUp);
    function onUp(e2) {
      e2.stopPropagation();
      document.removeEventListener(moveevent, onMove);
      document.removeEventListener(upevent, onUp);
      node.dispatchEvent(new CustomEvent("dragend"));
    }
    ;
  };
}
function getOnMove(node) {
  const track = node.parentNode;
  return function(e) {
    const { left, width } = track.getBoundingClientRect();
    const clickOffset = "touches" in e ? e.touches[0].clientX : e.clientX;
    const clickPos = Math.min(Math.max((clickOffset - left) / width, 0), 1) || 0;
    node.dispatchEvent(new CustomEvent("drag", { detail: clickPos }));
  };
}

// node_modules/@bulatdashiev/svelte-slider/src/Thumb.svelte
var file = "node_modules/@bulatdashiev/svelte-slider/src/Thumb.svelte";
function add_css(target) {
  append_styles(target, "svelte-8w8x88", '.thumb.svelte-8w8x88{position:absolute;top:50%;width:0;height:0}.thumb-content.svelte-8w8x88{position:relative;width:fit-content;height:fit-content;transform:translate(-50%, -50%)}.thumb-content.svelte-8w8x88::before{content:"";position:absolute;width:200%;height:200%;transform:translate(-25%, -25%) scale(0);border-radius:100vh;background:var(--thumb-bg, #5784fd);opacity:30%;transition:transform 100ms ease-in-out}.thumb-content.active.svelte-8w8x88::before{transform:translate(-25%, -25%) scale(1)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGh1bWIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFCRSxvQkFBTyxDQUNMLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxHQUFHLENBQ1IsS0FBSyxDQUFFLENBQUMsQ0FDUixNQUFNLENBQUUsQ0FDVixDQUVBLDRCQUFlLENBQ2IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLFdBQVcsQ0FDbEIsTUFBTSxDQUFFLFdBQVcsQ0FDbkIsU0FBUyxDQUFFLFVBQVUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUNqQyxDQUVBLDRCQUFjLFFBQVMsQ0FDckIsT0FBTyxDQUFFLEVBQUUsQ0FDWCxRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osU0FBUyxDQUFFLFVBQVUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FDekMsYUFBYSxDQUFFLEtBQUssQ0FDcEIsVUFBVSxDQUFFLElBQUksVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUNwQyxPQUFPLENBQUUsR0FBRyxDQUNaLFVBQVUsQ0FBRSxTQUFTLENBQUMsS0FBSyxDQUFDLFdBQzlCLENBRUEsY0FBYyxxQkFBTyxRQUFTLENBQzVCLFNBQVMsQ0FBRSxVQUFVLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUMxQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUaHVtYi5zdmVsdGUiXX0= */');
}
function create_fragment(ctx) {
  let div1;
  let div0;
  let div1_style_value;
  let handle_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "thumb-content svelte-8w8x88");
      toggle_class(
        div0,
        "active",
        /*active*/
        ctx[1]
      );
      add_location(div0, file, 7, 2, 252);
      attr_dev(div1, "class", "thumb svelte-8w8x88");
      attr_dev(div1, "style", div1_style_value = `left: ${/*pos*/
      ctx[0] * 100}%;`);
      add_location(div1, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(handle_action = handle.call(null, div1)),
          listen_dev(
            div1,
            "dragstart",
            /*dragstart_handler*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "drag",
            /*drag_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "dragend",
            /*dragend_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*active*/
      2) {
        toggle_class(
          div0,
          "active",
          /*active*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*pos*/
      1 && div1_style_value !== (div1_style_value = `left: ${/*pos*/
      ctx2[0] * 100}%;`)) {
        attr_dev(div1, "style", div1_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Thumb", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let active;
  let { pos } = $$props;
  $$self.$$.on_mount.push(function() {
    if (pos === void 0 && !("pos" in $$props || $$self.$$.bound[$$self.$$.props["pos"]])) {
      console.warn("<Thumb> was created without expected prop 'pos'");
    }
  });
  const writable_props = ["pos"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Thumb> was created with unknown prop '${key}'`);
  });
  const dragstart_handler = () => ($$invalidate(1, active = true), dispatch("active", true));
  const drag_handler = ({ detail: v }) => $$invalidate(0, pos = v);
  const dragend_handler = () => ($$invalidate(1, active = false), dispatch("active", false));
  $$self.$$set = ($$props2) => {
    if ("pos" in $$props2)
      $$invalidate(0, pos = $$props2.pos);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    handle,
    dispatch,
    pos,
    active
  });
  $$self.$inject_state = ($$props2) => {
    if ("pos" in $$props2)
      $$invalidate(0, pos = $$props2.pos);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    pos,
    active,
    dispatch,
    $$scope,
    slots,
    dragstart_handler,
    drag_handler,
    dragend_handler
  ];
}
var Thumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { pos: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Thumb",
      options,
      id: create_fragment.name
    });
  }
  get pos() {
    throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pos(value) {
    throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Thumb_default = Thumb;

// node_modules/@bulatdashiev/svelte-slider/src/Slider.svelte
var file2 = "node_modules/@bulatdashiev/svelte-slider/src/Slider.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1q9yxz9", "input.svelte-1q9yxz9{display:none}.track.svelte-1q9yxz9{margin:16px 8px;position:relative;height:4px;width:calc(100% - 16px);border-radius:100vh;background:var(--track-bg, #ebebeb)}.progress.svelte-1q9yxz9{position:absolute;left:0;right:0;top:0;bottom:0;border-radius:100vh;background:var(--progress-bg, #8abdff)}.thumb.svelte-1q9yxz9{width:16px;height:16px;border-radius:100vh;background:var(--thumb-bg, #5784fd)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2xpZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUErRUUsb0JBQU0sQ0FDSixPQUFPLENBQUUsSUFDWCxDQUVBLHFCQUFPLENBQ0wsTUFBTSxDQUFFLElBQUksQ0FBQyxHQUFHLENBQ2hCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE1BQU0sQ0FBRSxHQUFHLENBQ1gsS0FBSyxDQUFFLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FDeEIsYUFBYSxDQUFFLEtBQUssQ0FDcEIsVUFBVSxDQUFFLElBQUksVUFBVSxDQUFDLFFBQVEsQ0FDckMsQ0FFQSx3QkFBVSxDQUNSLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxDQUFDLENBQ1AsS0FBSyxDQUFFLENBQUMsQ0FDUixHQUFHLENBQUUsQ0FBQyxDQUNOLE1BQU0sQ0FBRSxDQUFDLENBQ1QsYUFBYSxDQUFFLEtBQUssQ0FDcEIsVUFBVSxDQUFFLElBQUksYUFBYSxDQUFDLFFBQVEsQ0FDeEMsQ0FFQSxxQkFBTyxDQUNMLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixhQUFhLENBQUUsS0FBSyxDQUNwQixVQUFVLENBQUUsSUFBSSxVQUFVLENBQUMsUUFBUSxDQUNyQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTbGlkZXIuc3ZlbHRlIl19 */");
}
var get_right_slot_changes = (dirty) => ({});
var get_right_slot_context = (ctx) => ({});
var get_left_slot_changes = (dirty) => ({});
var get_left_slot_context = (ctx) => ({});
function create_if_block_1(ctx) {
  let input;
  let input_value_value;
  let input_name_value;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true, class: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "number");
      input.value = input_value_value = /*value*/
      ctx[0][1];
      attr_dev(input, "name", input_name_value = /*name*/
      ctx[1][1]);
      attr_dev(input, "class", "svelte-1q9yxz9");
      add_location(input, file2, 2, 2, 72);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*value*/
      1 && input_value_value !== (input_value_value = /*value*/
      ctx2[0][1]) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (dirty & /*name*/
      2 && input_name_value !== (input_name_value = /*name*/
      ctx2[1][1])) {
        attr_dev(input, "name", input_name_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(2:0) {#if range}",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "thumb svelte-1q9yxz9");
      add_location(div, file2, 11, 8, 329);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(11:12)           ",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_3(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(10:22)         ",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const left_slot_template = (
    /*#slots*/
    ctx[10].left
  );
  const left_slot = create_slot(
    left_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_left_slot_context
  );
  const left_slot_or_fallback = left_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      if (left_slot_or_fallback)
        left_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (left_slot_or_fallback)
        left_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (left_slot_or_fallback) {
        left_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (left_slot) {
        if (left_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              left_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_left_slot_changes
            ),
            get_left_slot_context
          );
        }
      } else {
        if (left_slot_or_fallback && left_slot_or_fallback.p && (!current || dirty & /*$$scope*/
        32768)) {
          left_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(left_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(left_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (left_slot_or_fallback)
        left_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(9:2) <Thumb bind:pos={pos[0]} on:active={({ detail: v }) => active = v}>",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let thumb;
  let updating_pos;
  let current;
  function thumb_pos_binding_1(value) {
    ctx[13](value);
  }
  let thumb_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  if (
    /*pos*/
    ctx[3][1] !== void 0
  ) {
    thumb_props.pos = /*pos*/
    ctx[3][1];
  }
  thumb = new Thumb_default({ props: thumb_props, $$inline: true });
  binding_callbacks.push(() => bind(thumb, "pos", thumb_pos_binding_1));
  thumb.$on(
    "active",
    /*active_handler_1*/
    ctx[14]
  );
  const block = {
    c: function create() {
      create_component(thumb.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(thumb.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(thumb, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const thumb_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        thumb_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_pos && dirty & /*pos*/
      8) {
        updating_pos = true;
        thumb_changes.pos = /*pos*/
        ctx2[3][1];
        add_flush_callback(() => updating_pos = false);
      }
      thumb.$set(thumb_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(thumb.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(thumb.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(thumb, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(16:2) {#if range}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "thumb svelte-1q9yxz9");
      add_location(div, file2, 19, 10, 533);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(19:14)             ",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(18:25)           ",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const right_slot_template = (
    /*#slots*/
    ctx[10].right
  );
  const right_slot = create_slot(
    right_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_right_slot_context
  );
  const right_slot_or_fallback = right_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (right_slot_or_fallback)
        right_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (right_slot_or_fallback)
        right_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (right_slot_or_fallback) {
        right_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (right_slot) {
        if (right_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              right_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_right_slot_changes
            ),
            get_right_slot_context
          );
        }
      } else {
        if (right_slot_or_fallback && right_slot_or_fallback.p && (!current || dirty & /*$$scope*/
        32768)) {
          right_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(right_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(right_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (right_slot_or_fallback)
        right_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(17:4) <Thumb bind:pos={pos[1]} on:active={({ detail: v }) => active = v}>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let input;
  let input_value_value;
  let input_name_value;
  let t0;
  let t1;
  let div1;
  let div0;
  let t2;
  let thumb;
  let updating_pos;
  let t3;
  let current;
  let if_block0 = (
    /*range*/
    ctx[2] && create_if_block_1(ctx)
  );
  function thumb_pos_binding(value) {
    ctx[11](value);
  }
  let thumb_props = {
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  if (
    /*pos*/
    ctx[3][0] !== void 0
  ) {
    thumb_props.pos = /*pos*/
    ctx[3][0];
  }
  thumb = new Thumb_default({ props: thumb_props, $$inline: true });
  binding_callbacks.push(() => bind(thumb, "pos", thumb_pos_binding));
  thumb.$on(
    "active",
    /*active_handler*/
    ctx[12]
  );
  let if_block1 = (
    /*range*/
    ctx[2] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      t2 = space();
      create_component(thumb.$$.fragment);
      t3 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true, class: true });
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
      children(div0).forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      claim_component(thumb.$$.fragment, div1_nodes);
      t3 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "number");
      input.value = input_value_value = /*value*/
      ctx[0][0];
      attr_dev(input, "name", input_name_value = /*name*/
      ctx[1][0]);
      attr_dev(input, "class", "svelte-1q9yxz9");
      add_location(input, file2, 0, 0, 0);
      attr_dev(div0, "class", "progress svelte-1q9yxz9");
      attr_dev(
        div0,
        "style",
        /*progress*/
        ctx[5]
      );
      add_location(div0, file2, 5, 2, 159);
      attr_dev(div1, "class", "track svelte-1q9yxz9");
      add_location(div1, file2, 4, 0, 136);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div1, t2);
      mount_component(thumb, div1, null);
      append_hydration_dev(div1, t3);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*value*/
      1 && input_value_value !== (input_value_value = /*value*/
      ctx2[0][0]) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (!current || dirty & /*name*/
      2 && input_name_value !== (input_name_value = /*name*/
      ctx2[1][0])) {
        attr_dev(input, "name", input_name_value);
      }
      if (
        /*range*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & /*progress*/
      32) {
        attr_dev(
          div0,
          "style",
          /*progress*/
          ctx2[5]
        );
      }
      const thumb_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        thumb_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_pos && dirty & /*pos*/
      8) {
        updating_pos = true;
        thumb_changes.pos = /*pos*/
        ctx2[3][0];
        add_flush_callback(() => updating_pos = false);
      }
      thumb.$set(thumb_changes);
      if (
        /*range*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*range*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(thumb.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(thumb.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(div1);
      }
      if (if_block0)
        if_block0.d(detaching);
      destroy_component(thumb);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function checkPos(pos) {
  return [Math.min(...pos), Math.max(...pos)];
}
function instance2($$self, $$props, $$invalidate) {
  let progress;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slider", slots, ["default", "left", "right"]);
  const dispatch = createEventDispatcher();
  let { name = [] } = $$props;
  let { range = false } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { value = [min, max] } = $$props;
  let pos;
  let active = false;
  let { order = false } = $$props;
  function setValue(pos2) {
    const offset = min % step;
    const width = max - min;
    $$invalidate(0, value = pos2.map((v) => min + v * width).map((v) => Math.round((v - offset) / step) * step + offset));
    dispatch("input", value);
  }
  function setPos(value2) {
    $$invalidate(3, pos = value2.map((v) => Math.min(Math.max(v, min), max)).map((v) => (v - min) / (max - min)));
  }
  function clamp() {
    setPos(value);
    setValue(pos);
  }
  const writable_props = ["name", "range", "min", "max", "step", "value", "order"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Slider> was created with unknown prop '${key}'`);
  });
  function thumb_pos_binding(value2) {
    if ($$self.$$.not_equal(pos[0], value2)) {
      pos[0] = value2;
      $$invalidate(3, pos), $$invalidate(2, range), $$invalidate(9, order), $$invalidate(4, active);
    }
  }
  const active_handler = ({ detail: v }) => $$invalidate(4, active = v);
  function thumb_pos_binding_1(value2) {
    if ($$self.$$.not_equal(pos[1], value2)) {
      pos[1] = value2;
      $$invalidate(3, pos), $$invalidate(2, range), $$invalidate(9, order), $$invalidate(4, active);
    }
  }
  const active_handler_1 = ({ detail: v }) => $$invalidate(4, active = v);
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
    if ("range" in $$props2)
      $$invalidate(2, range = $$props2.range);
    if ("min" in $$props2)
      $$invalidate(6, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(7, max = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(8, step = $$props2.step);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("order" in $$props2)
      $$invalidate(9, order = $$props2.order);
    if ("$$scope" in $$props2)
      $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    Thumb: Thumb_default,
    dispatch,
    name,
    range,
    min,
    max,
    step,
    value,
    pos,
    active,
    order,
    setValue,
    setPos,
    checkPos,
    clamp,
    progress
  });
  $$self.$inject_state = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
    if ("range" in $$props2)
      $$invalidate(2, range = $$props2.range);
    if ("min" in $$props2)
      $$invalidate(6, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(7, max = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(8, step = $$props2.step);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("pos" in $$props2)
      $$invalidate(3, pos = $$props2.pos);
    if ("active" in $$props2)
      $$invalidate(4, active = $$props2.active);
    if ("order" in $$props2)
      $$invalidate(9, order = $$props2.order);
    if ("progress" in $$props2)
      $$invalidate(5, progress = $$props2.progress);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*range, order, active, pos*/
    540) {
      $:
        if (range && order && active)
          $$invalidate(3, pos = checkPos(pos));
    }
    if ($$self.$$.dirty & /*active, pos*/
    24) {
      $:
        if (active)
          setValue(pos);
    }
    if ($$self.$$.dirty & /*active, value*/
    17) {
      $:
        if (!active)
          setPos(value);
    }
    if ($$self.$$.dirty & /*min, max*/
    192) {
      $:
        min, max, clamp();
    }
    if ($$self.$$.dirty & /*range, pos*/
    12) {
      $:
        $$invalidate(5, progress = `
    left: ${range ? Math.min(pos[0], pos[1]) * 100 : 0}%;
    right: ${100 - Math.max(pos[0], range ? pos[1] : pos[0]) * 100}%;
  `);
    }
  };
  return [
    value,
    name,
    range,
    pos,
    active,
    progress,
    min,
    max,
    step,
    order,
    slots,
    thumb_pos_binding,
    active_handler,
    thumb_pos_binding_1,
    active_handler_1,
    $$scope
  ];
}
var Slider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        name: 1,
        range: 2,
        min: 6,
        max: 7,
        step: 8,
        value: 0,
        order: 9
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slider",
      options,
      id: create_fragment2.name
    });
  }
  get name() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get range() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get order() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set order(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Slider_default = Slider;
export {
  Slider_default as default
};
//# sourceMappingURL=@bulatdashiev_svelte-slider.js.map
